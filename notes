
- more examples
- readme
 - add marshal and unmarshal example

- benchmarks needs a better mix and not just strings

- UseTags in sen.Options

- separate package for field stuff?
- need string encoders (json and sen) in alt

- decomposer
 - how about funcs to serialize values?
  - precalc key as byte array (with quotes?)
  - check omit and then write both key and value
   - flag for need for space after :
   - sen flag?
  - if no write func then return indicator and value
  -

- writers
 - color
 - oj and sen

- Marshal for reflects
 - need a buildReflectJSON that take a reflect.Value instead of interface{}
  - stay with buildJSON for simple and reflect for structs
 - how to reduce the number of allocs?

----------------

- option to detect duplicate keys or make part of validator
 - change stack to include array and map or maybe just map and nil means array
  - check performance hit
  - check added condition of whether keys should be checked. If too high then copy code
 - or separate stack in func for key maps along with dip code

- regex op =~
  - /^xyz&/
 - in addition to parse callback support chan for results
 - cmd/oj
  - read args from file (SEN format)
   - also check ~/.oj.fin or ~/.oj - graphql emacs mode works well
  - palette in cfg file
  - build or restructure json
   - use a template based approach along with JSONPath
- advanced ops
 - in - a in [1,2,3]
 - exists, empty, or has
 - size or length - [?(@.x size > 3)] or [?(size @.x > 3)]
-------------

- Match a JavaScript regular expression. For example, [?(@.description =~ /cat.*/i)]
- Exists syntax? [?(@.x exists)]
QQ79661BQ
C7090F4B-D872-497A-93C4-5BCE84024103
