
- optimize marshal for structs
 - empty check inline with fill
  - pass in options
 - maybe stay with functions but make a separate string versions
  - change to include writing key

 - Marshal for reflects
  - need a buildReflectJSON that take a reflect.Value instead of interface{}
   - stay with buildJSON for simple and reflect for structs
  - how to reduce the number of allocs?

- benchmarks needs a better mix and not just strings
 - validate issue?

- pass args as pointer to struct instead of several bools (EncodeOptions)
 - need htmlsafe
 - need space after tag (0 < indent)
 - BytesAs

- writers
 - color
 - oj and sen

- change uft [x]byte

- more examples
- readme
 - add marshal and unmarshal example
 - examples
  - asm
  - decompose and alter
  - parse (oj, sen)
  - write (oj, sen, and pretty)

- unit tests for cmd/oj
----------------

- option to detect duplicate keys or make part of validator
 - change stack to include array and map or maybe just map and nil means array
  - check performance hit
  - check added condition of whether keys should be checked. If too high then copy code
 - or separate stack in func for key maps along with dip code

- regex op =~
  - /^xyz&/
 - in addition to parse callback support chan for results
 - cmd/oj
  - read args from file (SEN format)
   - also check ~/.oj.fin or ~/.oj - graphql emacs mode works well
  - palette in cfg file
  - build or restructure json
   - use a template based approach along with JSONPath
- advanced ops
 - in - a in [1,2,3]
 - exists, empty, or has
 - size or length - [?(@.x size > 3)] or [?(size @.x > 3)]
-------------

- Match a JavaScript regular expression. For example, [?(@.description =~ /cat.*/i)]
- Exists syntax? [?(@.x exists)]
